import { jest, describe, beforeEach, afterEach, it, expect } from '@jest/globals';\nimport request from 'supertest';\nimport express from 'express';\nimport { Pool } from 'pg';\nimport { createPairTradeRoutes } from '../../routes/pairTradeRoutes';\nimport { PairTradeTriggerDaemon } from '../../services/PairTradeTriggerDaemon';\n\n// Mock Pool\nconst mockPool = {\n  query: jest.fn()\n} as unknown as jest.Mocked<Pool>;\n\n// Mock Daemon\nconst mockDaemon = {\n  getStatus: jest.fn(),\n  getActiveTriggers: jest.fn(),\n  checkNow: jest.fn(),\n  setCheckInterval: jest.fn()\n} as unknown as jest.Mocked<PairTradeTriggerDaemon>;\n\ndescribe('PairTrade API Routes', () => {\n  let app: express.Application;\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    \n    app = express();\n    app.use(express.json());\n    \n    const routes = createPairTradeRoutes(mockPool, mockDaemon);\n    app.use('/api/pair-trades', routes);\n  });\n\n  describe('GET /api/pair-trades/triggers', () => {\n    it('should return all triggers', async () => {\n      const mockTriggers = [\n        {\n          id: 1,\n          token_a_symbol: 'SOL',\n          token_b_symbol: 'USDC',\n          current_direction: 'A_TO_B',\n          trigger_swap: false,\n          trigger_count: 5\n        }\n      ];\n\n      mockPool.query.mockResolvedValue({ rows: mockTriggers });\n\n      const response = await request(app)\n        .get('/api/pair-trades/triggers')\n        .expect(200);\n\n      expect(response.body).toEqual({\n        success: true,\n        triggers: mockTriggers,\n        count: 1\n      });\n    });\n\n    it('should handle database errors', async () => {\n      mockPool.query.mockRejectedValue(new Error('Database error'));\n\n      const response = await request(app)\n        .get('/api/pair-trades/triggers')\n        .expect(500);\n\n      expect(response.body).toEqual({\n        success: false,\n        error: 'Failed to fetch triggers'\n      });\n    });\n  });\n\n  describe('GET /api/pair-trades/triggers/active', () => {\n    it('should return active triggers via daemon', async () => {\n      const mockActiveTriggers = [\n        {\n          id: 1,\n          token_a_symbol: 'SOL',\n          token_b_symbol: 'USDC',\n          trigger_swap: true\n        }\n      ];\n\n      mockDaemon.getActiveTriggers.mockResolvedValue(mockActiveTriggers as any);\n\n      const response = await request(app)\n        .get('/api/pair-trades/triggers/active')\n        .expect(200);\n\n      expect(response.body).toEqual({\n        success: true,\n        triggers: mockActiveTriggers,\n        count: 1\n      });\n    });\n  });\n\n  describe('POST /api/pair-trades/trigger', () => {\n    it('should set a trigger successfully', async () => {\n      // Mock trigger exists\n      mockPool.query\n        .mockResolvedValueOnce({ // Check trigger exists\n          rows: [{\n            id: 1,\n            token_a_symbol: 'SOL',\n            token_b_symbol: 'USDC'\n          }]\n        })\n        .mockResolvedValueOnce({ // Update trigger\n          rowCount: 1\n        });\n\n      const response = await request(app)\n        .post('/api/pair-trades/trigger')\n        .send({\n          tokenA: 'So11111111111111111111111111111111111111112',\n          tokenB: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',\n          direction: 'A_TO_B'\n        })\n        .expect(200);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.message).toContain('Trigger set for SOL/USDC');\n    });\n\n    it('should validate required fields', async () => {\n      const response = await request(app)\n        .post('/api/pair-trades/trigger')\n        .send({\n          tokenA: 'SOL_MINT'\n          // Missing tokenB and direction\n        })\n        .expect(400);\n\n      expect(response.body).toEqual({\n        success: false,\n        error: 'tokenA, tokenB, and direction are required'\n      });\n    });\n\n    it('should validate direction values', async () => {\n      const response = await request(app)\n        .post('/api/pair-trades/trigger')\n        .send({\n          tokenA: 'SOL_MINT',\n          tokenB: 'USDC_MINT',\n          direction: 'INVALID'\n        })\n        .expect(400);\n\n      expect(response.body).toEqual({\n        success: false,\n        error: 'direction must be A_TO_B or B_TO_A'\n      });\n    });\n\n    it('should handle token pair not found', async () => {\n      mockPool.query.mockResolvedValue({ rows: [] });\n\n      const response = await request(app)\n        .post('/api/pair-trades/trigger')\n        .send({\n          tokenA: 'UNKNOWN_MINT',\n          tokenB: 'UNKNOWN_MINT2',\n          direction: 'A_TO_B'\n        })\n        .expect(404);\n\n      expect(response.body.success).toBe(false);\n      expect(response.body.error).toContain('No trigger configuration found');\n    });\n  });\n\n  describe('POST /api/pair-trades/trigger/hold', () => {\n    it('should set pair to HOLD', async () => {\n      mockPool.query.mockResolvedValue({ rowCount: 1 });\n\n      const response = await request(app)\n        .post('/api/pair-trades/trigger/hold')\n        .send({\n          tokenA: 'SOL_MINT',\n          tokenB: 'USDC_MINT'\n        })\n        .expect(200);\n\n      expect(response.body).toEqual({\n        success: true,\n        message: 'Pair set to HOLD - no swaps will be executed'\n      });\n    });\n\n    it('should handle pair not found', async () => {\n      mockPool.query.mockResolvedValue({ rowCount: 0 });\n\n      const response = await request(app)\n        .post('/api/pair-trades/trigger/hold')\n        .send({\n          tokenA: 'UNKNOWN_MINT',\n          tokenB: 'UNKNOWN_MINT2'\n        })\n        .expect(404);\n\n      expect(response.body).toEqual({\n        success: false,\n        error: 'Token pair not found'\n      });\n    });\n  });\n\n  describe('POST /api/pair-trades/trigger/manual-check', () => {\n    it('should trigger manual daemon check', async () => {\n      mockDaemon.checkNow.mockResolvedValue();\n\n      const response = await request(app)\n        .post('/api/pair-trades/trigger/manual-check')\n        .expect(200);\n\n      expect(response.body).toEqual({\n        success: true,\n        message: 'Manual trigger check completed'\n      });\n      \n      expect(mockDaemon.checkNow).toHaveBeenCalled();\n    });\n  });\n\n  describe('GET /api/pair-trades/daemon/status', () => {\n    it('should return daemon status', async () => {\n      const mockStatus = {\n        isRunning: true,\n        checkInterval: 5000\n      };\n      \n      mockDaemon.getStatus.mockReturnValue(mockStatus);\n\n      const response = await request(app)\n        .get('/api/pair-trades/daemon/status')\n        .expect(200);\n\n      expect(response.body).toEqual({\n        success: true,\n        daemon: mockStatus\n      });\n    });\n  });\n\n  describe('POST /api/pair-trades/daemon/interval', () => {\n    it('should update daemon interval', async () => {\n      const response = await request(app)\n        .post('/api/pair-trades/daemon/interval')\n        .send({ intervalMs: 10000 })\n        .expect(200);\n\n      expect(response.body.success).toBe(true);\n      expect(mockDaemon.setCheckInterval).toHaveBeenCalledWith(10000);\n    });\n\n    it('should validate minimum interval', async () => {\n      const response = await request(app)\n        .post('/api/pair-trades/daemon/interval')\n        .send({ intervalMs: 500 })\n        .expect(400);\n\n      expect(response.body).toEqual({\n        success: false,\n        error: 'intervalMs must be at least 1000'\n      });\n    });\n  });\n\n  describe('GET /api/pair-trades/strategies', () => {\n    it('should return all pair trade strategies', async () => {\n      const mockStrategies = [\n        {\n          id: 'strategy-1',\n          trading_wallet_public_key: 'wallet123',\n          token_a_symbol: 'SOL',\n          token_b_symbol: 'USDC',\n          current_position: 'A',\n          allocation_percentage: '50',\n          swap_count: '3',\n          is_active: true\n        }\n      ];\n\n      mockPool.query.mockResolvedValue({ rows: mockStrategies });\n\n      const response = await request(app)\n        .get('/api/pair-trades/strategies')\n        .expect(200);\n\n      expect(response.body).toEqual({\n        success: true,\n        strategies: mockStrategies,\n        count: 1\n      });\n    });\n  });\n\n  describe('POST /api/pair-trades/pair', () => {\n    it('should add new token pair', async () => {\n      mockPool.query.mockResolvedValue({ rows: [{ id: 1 }] });\n\n      const response = await request(app)\n        .post('/api/pair-trades/pair')\n        .send({\n          tokenAMint: 'SOL_MINT',\n          tokenBMint: 'USDC_MINT',\n          tokenASymbol: 'SOL',\n          tokenBSymbol: 'USDC',\n          preferredInitialToken: 'B'\n        })\n        .expect(200);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.message).toContain('Token pair SOL/USDC added successfully');\n    });\n\n    it('should handle duplicate pairs', async () => {\n      const error = new Error('duplicate key value violates unique constraint');\n      mockPool.query.mockRejectedValue(error);\n\n      const response = await request(app)\n        .post('/api/pair-trades/pair')\n        .send({\n          tokenAMint: 'SOL_MINT',\n          tokenBMint: 'USDC_MINT',\n          tokenASymbol: 'SOL',\n          tokenBSymbol: 'USDC',\n          preferredInitialToken: 'B'\n        })\n        .expect(409);\n\n      expect(response.body).toEqual({\n        success: false,\n        error: 'Token pair already exists'\n      });\n    });\n\n    it('should validate required fields for new pair', async () => {\n      const response = await request(app)\n        .post('/api/pair-trades/pair')\n        .send({\n          tokenAMint: 'SOL_MINT'\n          // Missing other required fields\n        })\n        .expect(400);\n\n      expect(response.body.success).toBe(false);\n      expect(response.body.error).toContain('All fields are required');\n    });\n  });\n});