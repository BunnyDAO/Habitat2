import { jest, describe, beforeEach, afterEach, it, expect } from '@jest/globals';\nimport { Pool } from 'pg';\nimport { PairTradeTriggerDaemon } from '../../services/PairTradeTriggerDaemon';\nimport { JobType } from '../../types/jobs';\n\n// Mock Pool\nconst mockPool = {\n  query: jest.fn()\n} as unknown as jest.Mocked<Pool>;\n\n// Mock worker\nconst mockWorker = {\n  executeSwap: jest.fn()\n};\n\n// Mock worker getter function\nconst mockGetWorker = jest.fn();\n\ndescribe('PairTradeTriggerDaemon', () => {\n  let daemon: PairTradeTriggerDaemon;\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    jest.useFakeTimers();\n    \n    daemon = new PairTradeTriggerDaemon(mockPool);\n    daemon.setWorkerGetter(mockGetWorker);\n  });\n\n  afterEach(async () => {\n    await daemon.stop();\n    jest.useRealTimers();\n  });\n\n  describe('Initialization and Control', () => {\n    it('should start and stop correctly', async () => {\n      // Mock no active triggers initially\n      mockPool.query.mockResolvedValue({ rows: [] });\n\n      await daemon.start();\n      expect(daemon.getStatus().isRunning).toBe(true);\n\n      await daemon.stop();\n      expect(daemon.getStatus().isRunning).toBe(false);\n    });\n\n    it('should not start twice', async () => {\n      mockPool.query.mockResolvedValue({ rows: [] });\n\n      await daemon.start();\n      await daemon.start(); // Second start should be ignored\n      \n      expect(daemon.getStatus().isRunning).toBe(true);\n    });\n\n    it('should handle stop when not running', async () => {\n      await daemon.stop(); // Should not throw\n      expect(daemon.getStatus().isRunning).toBe(false);\n    });\n  });\n\n  describe('Trigger Processing', () => {\n    it('should process active triggers', async () => {\n      const mockTrigger = {\n        id: 1,\n        token_a_mint: 'SOL_MINT',\n        token_b_mint: 'USDC_MINT',\n        token_a_symbol: 'SOL',\n        token_b_symbol: 'USDC',\n        current_direction: 'A_TO_B'\n      };\n\n      const mockStrategy = {\n        id: 'strategy-1',\n        trading_wallet_public_key: 'wallet123',\n        data: {\n          tokenAMint: 'SOL_MINT',\n          tokenBMint: 'USDC_MINT',\n          currentToken: 'A' // Needs to swap A->B\n        }\n      };\n\n      // Mock database queries\n      mockPool.query\n        .mockResolvedValueOnce({ rows: [mockTrigger] }) // Get active triggers\n        .mockResolvedValueOnce({ rows: [mockStrategy] }) // Get matching strategies\n        .mockResolvedValueOnce({ rowCount: 1 }); // Reset trigger\n\n      // Mock worker execution\n      mockGetWorker.mockResolvedValue(mockWorker);\n      mockWorker.executeSwap.mockResolvedValue({\n        success: true,\n        signature: 'swap-signature-123'\n      });\n\n      await daemon.checkNow();\n\n      // Verify swap was executed\n      expect(mockGetWorker).toHaveBeenCalledWith('strategy-1');\n      expect(mockWorker.executeSwap).toHaveBeenCalledWith('daemon-trigger');\n      \n      // Verify trigger was reset\n      expect(mockPool.query).toHaveBeenCalledWith(\n        expect.stringContaining('UPDATE pair_trade_triggers'),\n        [1]\n      );\n    });\n\n    it('should skip strategies already in correct position', async () => {\n      const mockTrigger = {\n        id: 1,\n        token_a_mint: 'SOL_MINT',\n        token_b_mint: 'USDC_MINT',\n        token_a_symbol: 'SOL',\n        token_b_symbol: 'USDC',\n        current_direction: 'A_TO_B'\n      };\n\n      const mockStrategy = {\n        id: 'strategy-1',\n        trading_wallet_public_key: 'wallet123',\n        data: {\n          tokenAMint: 'SOL_MINT',\n          tokenBMint: 'USDC_MINT',\n          currentToken: 'B' // Already in correct position\n        }\n      };\n\n      mockPool.query\n        .mockResolvedValueOnce({ rows: [mockTrigger] })\n        .mockResolvedValueOnce({ rows: [mockStrategy] })\n        .mockResolvedValueOnce({ rowCount: 1 });\n\n      await daemon.checkNow();\n\n      // Verify no swap was executed\n      expect(mockGetWorker).not.toHaveBeenCalled();\n      expect(mockWorker.executeSwap).not.toHaveBeenCalled();\n      \n      // But trigger should still be reset\n      expect(mockPool.query).toHaveBeenCalledWith(\n        expect.stringContaining('UPDATE pair_trade_triggers'),\n        [1]\n      );\n    });\n\n    it('should handle swap failures gracefully', async () => {\n      const mockTrigger = {\n        id: 1,\n        token_a_mint: 'SOL_MINT',\n        token_b_mint: 'USDC_MINT',\n        token_a_symbol: 'SOL',\n        token_b_symbol: 'USDC',\n        current_direction: 'A_TO_B'\n      };\n\n      const mockStrategy = {\n        id: 'strategy-1',\n        trading_wallet_public_key: 'wallet123',\n        data: {\n          currentToken: 'A'\n        }\n      };\n\n      mockPool.query\n        .mockResolvedValueOnce({ rows: [mockTrigger] })\n        .mockResolvedValueOnce({ rows: [mockStrategy] })\n        .mockResolvedValueOnce({ rowCount: 1 });\n\n      // Mock swap failure\n      mockGetWorker.mockResolvedValue(mockWorker);\n      mockWorker.executeSwap.mockResolvedValue({\n        success: false,\n        error: 'Insufficient balance'\n      });\n\n      await daemon.checkNow();\n\n      // Should still reset trigger even after failure\n      expect(mockPool.query).toHaveBeenCalledWith(\n        expect.stringContaining('UPDATE pair_trade_triggers'),\n        [1]\n      );\n    });\n\n    it('should handle missing workers', async () => {\n      const mockTrigger = {\n        id: 1,\n        token_a_mint: 'SOL_MINT',\n        token_b_mint: 'USDC_MINT',\n        current_direction: 'A_TO_B'\n      };\n\n      const mockStrategy = {\n        id: 'strategy-1',\n        data: { currentToken: 'A' }\n      };\n\n      mockPool.query\n        .mockResolvedValueOnce({ rows: [mockTrigger] })\n        .mockResolvedValueOnce({ rows: [mockStrategy] })\n        .mockResolvedValueOnce({ rowCount: 1 });\n\n      // Mock worker not found\n      mockGetWorker.mockResolvedValue(null);\n\n      await daemon.checkNow();\n\n      // Should handle gracefully and reset trigger\n      expect(mockPool.query).toHaveBeenCalledWith(\n        expect.stringContaining('UPDATE pair_trade_triggers'),\n        [1]\n      );\n    });\n  });\n\n  describe('Status and Configuration', () => {\n    it('should return correct status', () => {\n      const status = daemon.getStatus();\n      expect(status).toEqual({\n        isRunning: false,\n        checkInterval: 5000\n      });\n    });\n\n    it('should update check interval', () => {\n      daemon.setCheckInterval(10000);\n      expect(daemon.getStatus().checkInterval).toBe(10000);\n    });\n\n    it('should reject invalid intervals', () => {\n      expect(() => daemon.setCheckInterval(500)).toThrow();\n    });\n\n    it('should get active triggers', async () => {\n      const mockTriggers = [\n        {\n          id: 1,\n          token_a_mint: 'SOL_MINT',\n          token_b_mint: 'USDC_MINT',\n          token_a_symbol: 'SOL',\n          token_b_symbol: 'USDC',\n          preferred_initial_token: 'B',\n          current_direction: 'A_TO_B',\n          trigger_swap: true,\n          trigger_count: 5\n        }\n      ];\n\n      mockPool.query.mockResolvedValue({ rows: mockTriggers });\n\n      const triggers = await daemon.getActiveTriggers();\n      \n      expect(triggers).toHaveLength(1);\n      expect(triggers[0].token_a_symbol).toBe('SOL');\n      expect(triggers[0].trigger_swap).toBe(true);\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should handle database errors gracefully', async () => {\n      mockPool.query.mockRejectedValue(new Error('Database connection failed'));\n\n      // Should not throw\n      await daemon.checkNow();\n      \n      // Should continue running\n      expect(daemon.getStatus().isRunning).toBe(false); // Not started yet\n    });\n\n    it('should handle worker execution errors', async () => {\n      const mockTrigger = {\n        id: 1,\n        current_direction: 'A_TO_B'\n      };\n\n      const mockStrategy = {\n        id: 'strategy-1',\n        data: { currentToken: 'A' }\n      };\n\n      mockPool.query\n        .mockResolvedValueOnce({ rows: [mockTrigger] })\n        .mockResolvedValueOnce({ rows: [mockStrategy] })\n        .mockResolvedValueOnce({ rowCount: 1 });\n\n      // Mock worker execution error\n      mockGetWorker.mockRejectedValue(new Error('Worker failed'));\n\n      await daemon.checkNow();\n\n      // Should still reset trigger\n      expect(mockPool.query).toHaveBeenCalledWith(\n        expect.stringContaining('UPDATE pair_trade_triggers'),\n        [1]\n      );\n    });\n  });\n\n  describe('Periodic Execution', () => {\n    it('should execute checks periodically when running', async () => {\n      mockPool.query.mockResolvedValue({ rows: [] });\n\n      await daemon.start();\n\n      // Advance timer to trigger periodic check\n      jest.advanceTimersByTime(6000); // More than 5000ms interval\n\n      // Should have made periodic database queries\n      expect(mockPool.query).toHaveBeenCalledWith(\n        expect.stringContaining('SELECT * FROM pair_trade_triggers'),\n        expect.any(Array)\n      );\n\n      await daemon.stop();\n    });\n  });\n});