import { jest, describe, beforeEach, afterEach, it, expect } from '@jest/globals';\nimport { PairTradeWorker } from '../../workers/PairTradeWorker';\nimport { PairTradeJob, JobType } from '../../types/jobs';\nimport { TokenService } from '../../services/TokenService';\nimport { PublicKey, Keypair, Connection } from '@solana/web3.js';\nimport { Pool } from 'pg';\n\n// Mock fetch for Jupiter API calls\nglobal.fetch = jest.fn() as jest.MockedFunction<typeof fetch>;\n\n// Mock TokenService\nconst mockTokenService = {\n  validateTokenPair: jest.fn(),\n  getTokenInfo: jest.fn(),\n} as unknown as jest.Mocked<TokenService>;\n\n// Mock Pool\nconst mockPool = {\n  query: jest.fn()\n} as unknown as jest.Mocked<Pool>;\n\n// Mock Solana Connection\nconst mockConnection = {\n  getBalance: jest.fn(),\n  getParsedTokenAccountsByOwner: jest.fn(),\n  getAccountInfo: jest.fn(),\n  getLatestBlockhash: jest.fn(),\n  sendTransaction: jest.fn(),\n  confirmTransaction: jest.fn(),\n} as any;\n\n// Mock console to capture logs\nconst mockConsole = {\n  log: jest.fn(),\n  error: jest.fn()\n};\n\ndescribe('PairTradeWorker - Database Integration Tests', () => {\n  let worker: PairTradeWorker;\n  let mockJob: PairTradeJob;\n  let mockKeypair: Keypair;\n  let mockFetch: jest.MockedFunction<typeof fetch>;\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    \n    // Setup test keypair\n    mockKeypair = Keypair.generate();\n    mockFetch = global.fetch as jest.MockedFunction<typeof fetch>;\n\n    // Create base pair trade job\n    mockJob = {\n      id: 'test-pair-trade-db-1',\n      type: JobType.PAIR_TRADE,\n      tradingWalletPublicKey: mockKeypair.publicKey.toString(),\n      tradingWalletSecretKey: mockKeypair.secretKey,\n      tokenAMint: 'So11111111111111111111111111111111111111112', // SOL\n      tokenBMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',  // USDC\n      tokenASymbol: 'SOL',\n      tokenBSymbol: 'USDC', \n      allocationPercentage: 50,\n      currentToken: null as any, // Initial setup\n      maxSlippage: 1.0,\n      autoRebalance: false,\n      isActive: true,\n      lastActivity: new Date().toISOString(),\n      createdAt: new Date().toISOString(),\n      swapHistory: [],\n      profitTracking: {\n        initialBalance: 1000,\n        currentBalance: 1000,\n        totalProfit: 0,\n        profitHistory: [],\n        trades: []\n      }\n    };\n\n    // Setup comprehensive connection mocks\n    mockConnection.getBalance.mockResolvedValue(10 * 1e9); // 10 SOL default\n    mockConnection.getAccountInfo.mockResolvedValue({ data: 'mock-account-exists' });\n    mockConnection.getLatestBlockhash.mockResolvedValue({ blockhash: 'mock-blockhash' });\n    mockConnection.sendTransaction.mockResolvedValue('mock-signature-123');\n    mockConnection.confirmTransaction.mockResolvedValue({ value: { err: null } });\n\n    // Mock console methods\n    jest.spyOn(console, 'log').mockImplementation(mockConsole.log);\n    jest.spyOn(console, 'error').mockImplementation(mockConsole.error);\n\n    // Create worker instance\n    worker = new PairTradeWorker(mockJob, 'https://api.mainnet-beta.solana.com', mockTokenService, mockPool);\n    (worker as any).connection = mockConnection;\n  });\n\n  afterEach(() => {\n    jest.restoreAllMocks();\n  });\n\n  describe('Database Integration - Initial Position Setup', () => {\n    it('should fetch trigger info from database on start', async () => {\n      // Mock database response\n      mockPool.query.mockResolvedValue({\n        rows: [{\n          id: 1,\n          token_a_mint: 'So11111111111111111111111111111111111111112',\n          token_b_mint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',\n          token_a_symbol: 'SOL',\n          token_b_symbol: 'USDC',\n          preferred_initial_token: 'B', // Prefer USDC\n          current_direction: 'HOLD',\n          trigger_swap: false\n        }]\n      });\n\n      // Mock token validation\n      mockTokenService.validateTokenPair.mockResolvedValue({ isValid: true });\n\n      // Mock the start method to avoid real connection creation\n      const mockStart = jest.spyOn(worker as any, 'start').mockImplementation(async () => {\n        const validation = await (worker as any).tokenService.validateTokenPair(\n          (worker as any).job.tokenAMint,\n          (worker as any).job.tokenBMint\n        );\n        if (!validation.isValid) {\n          throw new Error(`Invalid token pair: ${validation.error}`);\n        }\n        \n        // Simulate initial setup\n        const triggerInfo = await (worker as any).getTriggerInfo(\n          (worker as any).job.tokenAMint,\n          (worker as any).job.tokenBMint\n        );\n        \n        if (triggerInfo) {\n          (worker as any).job.currentToken = triggerInfo.preferred_initial_token;\n        }\n        \n        (worker as any).isRunning = true;\n      });\n\n      await worker.start();\n\n      // Verify database query was made\n      expect(mockPool.query).toHaveBeenCalledWith(\n        expect.stringContaining('SELECT * FROM pair_trade_triggers'),\n        ['So11111111111111111111111111111111111111112', 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v']\n      );\n\n      // Verify preferred token was set\n      expect(mockJob.currentToken).toBe('B');\n      \n      mockStart.mockRestore();\n    });\n\n    it('should setup initial position with SOL swap to preferred token', async () => {\n      // Mock database response preferring USDC (token B)\n      mockPool.query.mockResolvedValue({\n        rows: [{\n          preferred_initial_token: 'B'\n        }]\n      });\n\n      // Mock Jupiter quote and swap\n      const mockQuote = {\n        inputMint: 'So11111111111111111111111111111111111111112',\n        outputMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',\n        inAmount: (5 * 1e9).toString(), // 50% of 10 SOL\n        outAmount: (5 * 1e6).toString(), // 5 USDC\n        slippageBps: 100\n      };\n\n      mockFetch.mockResolvedValue({\n        ok: true,\n        json: async () => mockQuote\n      } as Response);\n\n      // Mock token info for decimals\n      mockTokenService.getTokenInfo\n        .mockResolvedValueOnce({\n          decimals: 6,\n          mintAddress: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',\n          symbol: 'USDC',\n          name: 'USD Coin',\n          category: 'stablecoin' as const,\n          isActive: true,\n          lastUpdated: new Date()\n        });\n\n      // Mock executeJupiterSwap\n      const mockExecuteJupiterSwap = jest.spyOn(worker as any, 'executeJupiterSwap').mockResolvedValue({\n        success: true,\n        signature: 'initial-setup-signature'\n      });\n\n      // Call setupInitialPosition directly\n      await (worker as any).setupInitialPosition();\n\n      // Verify SOL was swapped to USDC\n      expect(mockFetch).toHaveBeenCalledWith(\n        expect.stringContaining('jupiter')\n      );\n      expect(mockExecuteJupiterSwap).toHaveBeenCalled();\n      \n      // Verify job state was updated\n      expect(mockJob.currentToken).toBe('B');\n      expect(mockJob.lastSwapTimestamp).toBeTruthy();\n      expect(mockJob.swapHistory).toHaveLength(1);\n      \n      const swapRecord = mockJob.swapHistory[0];\n      expect(swapRecord.fromToken).toBe('SOL');\n      expect(swapRecord.toToken).toBe('B');\n      \n      mockExecuteJupiterSwap.mockRestore();\n    });\n\n    it('should handle missing trigger info gracefully', async () => {\n      // Mock no database record found\n      mockPool.query.mockResolvedValue({ rows: [] });\n\n      // Call getTriggerInfo directly\n      const triggerInfo = await (worker as any).getTriggerInfo('SOL_MINT', 'USDC_MINT');\n      \n      expect(triggerInfo).toBeNull();\n      expect(mockPool.query).toHaveBeenCalledWith(\n        expect.stringContaining('SELECT * FROM pair_trade_triggers'),\n        ['SOL_MINT', 'USDC_MINT']\n      );\n    });\n\n    it('should default to token A when no trigger info found', async () => {\n      // Mock no database record\n      mockPool.query.mockResolvedValue({ rows: [] });\n\n      await (worker as any).setupInitialPosition();\n\n      // Should default to token A\n      expect(mockJob.currentToken).toBe('A');\n      expect(mockConsole.log).toHaveBeenCalledWith(\n        expect.stringContaining('No trigger info found, defaulting to token A')\n      );\n    });\n\n    it('should handle database errors during setup', async () => {\n      // Mock database error\n      mockPool.query.mockRejectedValue(new Error('Database connection failed'));\n\n      await (worker as any).setupInitialPosition();\n\n      // Should fallback to token A\n      expect(mockJob.currentToken).toBe('A');\n      expect(mockConsole.error).toHaveBeenCalledWith(\n        expect.stringContaining('Error in initial position setup'),\n        expect.any(Error)\n      );\n    });\n\n    it('should skip initial setup if already has position', () => {\n      // Mock job with existing position\n      mockJob.currentToken = 'B';\n      mockJob.swapHistory = [{\n        timestamp: '2025-07-22T10:00:00Z',\n        fromToken: 'A',\n        toToken: 'B',\n        fromAmount: 5,\n        toAmount: 5,\n        price: 1,\n        profit: 0\n      }];\n\n      const hasSetup = (worker as any).hasInitialPositionSetup();\n      expect(hasSetup).toBe(true);\n    });\n  });\n\n  describe('Trigger Status Integration', () => {\n    it('should get current trigger status', async () => {\n      const mockTriggerInfo = {\n        id: 1,\n        token_a_symbol: 'SOL',\n        token_b_symbol: 'USDC',\n        current_direction: 'A_TO_B',\n        trigger_swap: true,\n        trigger_count: 3\n      };\n\n      mockPool.query.mockResolvedValue({ rows: [mockTriggerInfo] });\n\n      const status = await worker.getTriggerStatus();\n      \n      expect(status).toBeTruthy();\n      expect(status?.current_direction).toBe('A_TO_B');\n      expect(status?.trigger_swap).toBe(true);\n    });\n\n    it('should return null when no trigger found', async () => {\n      mockPool.query.mockResolvedValue({ rows: [] });\n\n      const status = await worker.getTriggerStatus();\n      expect(status).toBeNull();\n    });\n  });\n});